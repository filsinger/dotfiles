#!/usr/bin/env bash

shopt -s globstar
declare NO_WINDOW_SYSTEM
declare -a EMACS_ADDITIONAL_ARGS
declare FORCE_NEW_INSTANCE
declare -a EMACS_ARGS

# try and detect if we are running from a remote session
if [ -n "$SSH_CLIENT" ] || [ -n "$SSH_TTY" ]; then
	SESSION_TYPE=remote/ssh
fi

# If we aren't connected via remote connection
# lets try and run a graphical version of emacs.
if [ -z "$SESSION_TYPE" ]; then
    case "$OSTYPE" in
        cygwin)
            # Check program files first
            for emacs_bin_folder in "$(cygpath -u 'c:/Program Files/Emacs')"/*/bin; do
                if [[ -d "$emacs_bin_folder" ]]; then
                    [[ -x "$emacs_bin_folder/emacs.exe" ]] && EMACS_BIN="$emacs_bin_folder/emacs.exe"
                    [[ -x "$emacs_bin_folder/emacs.exe" ]] && EMACSCLIENT_BIN="$emacs_bin_folder/emacsclientw.exe"
                fi
            done

            # If we don't have a useable version, check c:/bin/emacs
            emacs_bin_folder=$(cygpath -u 'c:/bin/emacs/bin')
            [[ -x "$emacs_bin_folder/runemacs.exe" ]] && EMACS_BIN="$emacs_bin_folder/runemacs.exe"
            [[ -x "$emacs_bin_folder/emacsclientw.exe" ]] && EMACSCLIENT_BIN="$emacs_bin_folder/emacsclientw.exe"

            ;;

        darwin*)
            if [[ -z "$TMUX_PANE" ]]; then # don't try and open the emacs.app version if within a tmux session
                EMACS_APP="/Applications/Emacs.app/"
                if [ -d "$EMACS_APP" ]; then
                    EMACS_BIN="$EMACS_APP/Contents/MacOS/Emacs"
                    EMACSCLIENT_BIN="$EMACS_APP/Contents/MacOS/bin/emacsclient"

                    [[ ! -x $EMACS_BIN ]] && EMACS_BIN="$EMACS_APP/Contents/MacOS/Emacs-arm64-11"
                    [[ ! -x $EMACSCLIENT_BIN ]] && EMACSCLIENT_BIN="$EMACS_APP/Contents/MacOS/emacs-arm64-11/emacsclient"
                fi
            fi
            ;;

        *)
            if [[ -x /usr/bin/wslpath ]]; then
                # Running in WSL and not in an SSH session
                for emacs_bin_folder in "$(wslpath -u 'c:/Program Files/Emacs')"/*/bin; do
                    if [[ -d "$emacs_bin_folder" ]]; then
                        [[ -x "$emacs_bin_folder/emacs.exe" ]] && EMACS_BIN="$emacs_bin_folder/emacs.exe"
                        [[ -x "$emacs_bin_folder/emacs.exe" ]] && EMACSCLIENT_BIN="$emacs_bin_folder/emacsclientw.exe"
                    fi
                done

                # If we don't have a useable version yet, check c:/bin/emacs
                emacs_bin_folder=$(wslpath -u 'c:/bin/emacs/bin')
                [[ -x "$emacs_bin_folder/runemacs.exe" ]] && EMACS_BIN="$emacs_bin_folder/runemacs.exe"
                [[ -x "$emacs_bin_folder/emacsclientw.exe" ]] && EMACSCLIENT_BIN="$emacs_bin_folder/emacsclientw.exe"

            fi

            [[ ! -x $EMACS_BIN ]] && EMACS_BIN=$(which emacs 2> /dev/null)
            [[ ! -x $EMACSCLIENT_BIN ]] && EMACSCLIENT_BIN=$(which emacsclient 2> /dev/null)

            if [[ ! -x "$EMACS_BIN" ]]; then
                TOOLBOX_BIN=$(which toolbox 2> /dev/null)
                # cant find the emacs binary, check if toolbox is available
                # and run emacs through a 'dev' toolbox.
                if [[ -x "$TOOLBOX_BIN" ]]; then
                    TOOLBOX_CONTAINER="dev"
                    CONTAINER_COMMAND="$TOOLBOX_BIN run -c $TOOLBOX_CONTAINER"
                    EMACS_BIN="emacs"
                    EMACSCLIENT_BIN="emacsclient"
                fi
            fi

            ;;
    esac
fi

if [[ ! -v TOOLBOX_CONTAINER ]]; then
    # If we haven't set an emacs binary based on platform, try and
    # run a default one (should the terminal version).
    [[ -x $EMACS_BIN ]] || EMACS_BIN=$(which emacs 2> /dev/null);
    [[ -x $EMACSCLIENT_BIN ]] || EMACSCLIENT_BIN=$(which emacsclient 2> /dev/null)
fi

# Don't run emacs client if we havent passed any params
(( $# == 0 )) && unset EMACSCLIENT_BIN

for arg in "$@"; do
    case $arg in
        *"--eval"*) # Don't run emacs client if trying to evaluate an expression'
            FORCE_NEW_INSTANCE=1
            EMACS_ARGS+=("$arg")
            ;;
        --new-instance) # Don't run emacs client if --new-instance is passed as an argument
            FORCE_NEW_INSTANCE=1
            ;;
        *)
            EMACS_ARGS+=("$arg")
            ;;
    esac
done

(( FORCE_NEW_INSTANCE == 1 )) && unset EMACSCLIENT_BIN

# if we are running in ranger, don't use the windowing system
[[ ! -z $RANGER_LEVEL ]] && NO_WINDOW_SYSTEM=1

# if we are running in yazi, don't use the windowing system
[[ ! -z $YAZI_LEVEL ]] && NO_WINDOW_SYSTEM=1

# Don't use windowsing system if we launched in a way that should use the terminal
(( NO_WINDOW_SYSTEM == 1 )) && EMACS_ADDITIONAL_ARGS+=('--no-window-system')

# Try and run emacs
if [[ -n "$EMACS_BIN" ]]; then
    if [[ -n "$EMACSCLIENT_BIN" ]]; then
        echo "When done with a buffer, type C-x #"

        if [[ "$SESSION_TYPE" != "remote/ssh" ]] && [[ -z "$CONTAINER_COMMAND" ]]; then
            # The path of EMACS_BIN needs to be translated
            # if we are running in cygwin or wsl. Don't
            # translate if we are running in an SSH session
            [[ -x /usr/bin/cygpath ]] && EMACS_BIN=$(cygpath -m "$EMACS_BIN")
            [[ -x /usr/bin/wslpath ]] && EMACS_BIN=$(wslpath -m "$EMACS_BIN")
        fi

        if [[ -v CONTAINER_COMMAND ]]; then
            $CONTAINER_COMMAND "$EMACSCLIENT_BIN" "${EMACS_ADDITIONAL_ARGS[@]}" --alternate-editor="$EMACS_BIN" "${EMACS_ARGS[@]}"
        else
            "$EMACSCLIENT_BIN" "${EMACS_ADDITIONAL_ARGS[@]}" --alternate-editor="$EMACS_BIN" "${EMACS_ARGS[@]}"
        fi

        exit $?
    else

        # set LSP_USE_PLISTS based on https://emacs-lsp.github.io/lsp-mode/page/performance/#use-plists-for-deserialization
        #export LSP_USE_PLISTS=true
        if [[ -v CONTAINER_COMMAND ]]; then
            $CONTAINER_COMMAND "$EMACS_BIN" --no-splash "${EMACS_ADDITIONAL_ARGS[@]}" "${EMACS_ARGS[@]}"
        else
            "$EMACS_BIN" --no-splash "${EMACS_ADDITIONAL_ARGS[@]}" "${EMACS_ARGS[@]}"
        fi
        exit $?
    fi
fi

# return an error if we reach this point
exit 1
